__author__ = 'flipajs'

import pickle
import numpy as np
import math
import matplotlib.pyplot as plt
import my_utils

#file = open('../out/regions_2pkl', 'rb')
file = open('../out/collisions/regions_306pkl', 'rb')

regions = pickle.load(file)
file.close()

mser = regions[3]

num_px = mser['area']
a = np.zeros((2, num_px))

i = 0
points = []
for rle in mser['rle']:
    for c in range(rle['col1'], rle['col2']+1):
        #we must invert Y axis
        print c-mser['cx'], -(rle['line']-mser['cy'])
        a[:, i] = [c-mser['cx'], -(rle['line']-mser['cy'])]
        points.append([c-mser['cx'] + 50, (rle['line']-mser['cy']) + 50])
        i += 1


points = np.float32(np.vstack(points))


import numpy as np
from numpy import random
import cv2, cv


def make_gaussians(cluster_n, img_size):
    points = []
    ref_distrs = []
    for i in xrange(cluster_n):
        mean = (0.1 + 0.8*random.rand(2)) * img_size
        a = (random.rand(2, 2)-0.5)*img_size*0.1
        cov = np.dot(a.T, a) + img_size*0.05*np.eye(2)
        n = 100 + random.randint(900)
        pts = random.multivariate_normal(mean, cov, n)
        points.append( pts )
        ref_distrs.append( (mean, cov) )
    points = np.float32( np.vstack(points) )
    return points, ref_distrs

def draw_gaussain(img, mean, cov, color):
    x, y = np.int32(mean)
    w, u, vt = cv2.SVDecomp(cov)
    ang = np.rad2deg( np.arctan2(u[1, 0], u[0, 0]) )
    s1, s2 = np.sqrt(w)*3.0
    cv2.ellipse(img, (x, y), (s1, s2), ang, 0, 360, color, 1, cv.CV_AA)


import time

if __name__ == '__main__':
    cluster_n = 3
    img_size = 100

    print 'press any key to update distributions, ESC - exit\n'

    while True:
        print 'EM (opencv) ...'

        start = time.time()
        em = cv2.EM(points, params = dict( nclusters = cluster_n, cov_mat_type = cv2.EM_COV_MAT_GENERIC) )
        end = time.time()
        print end - start

        means = em.getMeans()
        covs = np.zeros((cluster_n, 2, 2), np.float32)
        covs = em.getCovs(covs)         # FIXME
        found_distrs = zip(means, covs)
        print 'ready!\n'

        img = np.zeros((img_size, img_size, 3), np.uint8)
        for x, y in np.int32(points):
            cv2.circle(img, (x, y), 1, (255, 255, 255), -1)

        for m, cov in found_distrs:
            draw_gaussain(img, m, cov, (0, 0, 255))

        cv2.imshow('gaussian mixture', img)
        ch = cv2.waitKey(0)
        if ch == 27:
            break
